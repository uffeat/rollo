<!--
* About
- Blog route based on non-blocking rendering from stataic data.
- Frontmatter -> meta + html takes place at runtime. Could
  instead be integrated in custom build process, but the current
  runtime solution is pretty fast!
- The frontmatter -> meta + html split is quite primitive, but it works!
- Primarily styled with Tailwind, but
  - uses in-module sheet for more advanced stuff
  - uses Bootstrap for card-stuff.
- Uses residuals rather than query for aux data, which goes against my own 
  recommendations, but nested (residual-based) routing just feels natural 
  for blogs.

* TODO
- Things work, but the handling of residuals in the route part could
  probably be refactored to something more elegant; consider using
  reactive state tools.
- Currently, the switch between 'items-view' and 'post-view' is done by
  toggling `display: none` (the 'hidden' class). This might be the right 
  approach, but consider if DOM i/o would be cleaner.
- The non-blocking rendering is already handled in an OK way, but to further
  improve (and to generally improve the UX) consider introducing:
  - pagination (cursor-based with a fixed chunk size), or
  - a "load more" approach, or
  - an intersection observer-based approach
  ... probably not super trivial in concert with the non-blocking rendering...
- Consider registering the click handler on 'items', rather than on each card.
- Consider using progressive images... and/or perhaps placeholders.
-->

<style global>
  /* Controls cards per row */
  #app[state-path="/blog"] [page] {
    --basis: 100%;
  }
  #app[state-path="/blog"][state-md] [page] {
    --gap: 0.5rem;
    --items: 2;
    --basis: calc(calc(100% / var(--items)) - var(--gap));
  }
  #app[state-path="/blog"][state-xl] [page] {
    --items: 3;
  }

  /* Images in post */
  #app[state-path="/blog"] [post] p:has(> img) {
    display: flex;
    justify-content: center;
  }
</style>

<script type="module">
  const { component } = await use("@/component");
  const { layout } = await use("@/layout/");
  const { reactive, ref } = await use("@/state");
  const { marked } = await use("@/marked");
  const { YAML } = await use("@/yaml");
  const { Sheet, css } = await use("@/sheet");
  const { router, Nav, NavLink } = await use("@/router/");
  const { toTop } = await use("@/tools/scroll");

  const START = "/content".length - 2;
  const END = ".md".length;
  const LINK = "a.nav-link";

  const items = component.div(
    "w-full flex justify-between flex-wrap gap-y-3 gap-x-(--gap)",
    {}
  );
  items.attribute.items = true;

  const page = component.main("container mt-3 mb-3", items);
  page.attribute.page = true;

  /* 'work-in-progress' map */
  const building = new Map();

  /* Renders card (and adds to DOM) and renders post */
  const Item = ({ html, meta, path, resolve }) => {
    const card = component.div(
      "card h-full basis-(--basis)",
      {
        parent: items,
      },
      component.img("card-img-top", { src: `${use.meta.base}${meta.image}` }),
      component.div(
        "card-body nav flex flex-col",
        {},
        component.a(
          "nav-link cursor-pointer",
          component.h1("card-title", { text: meta.title })
        ),
        component.p("card-text", { text: meta.abstract })
      ),
      component.div("card-footer min-h-8")
    );
    card.attribute.card = path;

    /* Create post. NOTE Defer adding to the DOM */
    const post = component.div("hidden", { innerHTML: html });
    post.attribute.post = path;
    /* Store on card detail for later retrival via card */
    card.detail.post = post;

    card.on.click = (event) => {
      if (event.target.matches(LINK) || event.target.closest(LINK)) {
        router("/blog" + path);
      }
    };
    resolve(card);
    building.delete(path);
  };

  const paths = (await use("/content/meta/paths.json")).filter((p) =>
    p.startsWith("/blog/")
  );

  /* Render items from static files.
  IMPORTANT This module is imported @ router set up. Awaiting rendering a large 
  number of items could result in a hangins app (although static file import
  is much faster than fetch from server). To mitigate, rendering is done 
  non-blocking. However, an item may be requested before it has rendered!
  This is handled by maintaining an 'work-in-progress' map, so that rendering
  can become "blocking if needed." */
  for (const path of paths) {
    const { promise, resolve } = Promise.withResolvers();
    const _path = "/" + path.slice(START, -END).toLowerCase();
    building.set(_path, promise);
    use(`/content${path}`).then((text) => {
      const [yaml, md] = text.split("---").slice(1);
      const meta = YAML.parse(yaml);
      const html = marked.parse(md);
      Item({ html, meta, path: _path, resolve });
    });
  }

  export default function () {
    /* Return route */
    return async (mode, query, ...residuals) => {
      if (mode.enter || mode.update) {
        if (mode.enter) {
          layout.clear(":not([slot])");
          layout.append(page);
        }
        if (residuals.length) {
          const path = "/" + residuals.at(0).toLowerCase();

          let card = page.find(`[card="${path}"]`);
          if (!card) {
            const promise = building.get(path);
            if (promise) {
              card = await promise;
            } else {
              // no such post, let router error handler deal with it
              // or early-return here
              router.error(path)
              return;
            }
          }

          // hide any currently visible post
          const previous = page.find(`[post]:not(.hidden)`);
          if (previous) {
            previous.classes.add("hidden");
          }

          const post = card.detail.post;
          items.classes.add("hidden");
          post.classes.remove("hidden");
          post.parent = page;
          toTop(post);
        } else {
          if (mode.update) {
            /* Updating without residuals: Hide any previous post and show items */
            const previous = page.find(`[post]:not(.hidden)`);
            if (previous) {
              previous.classes.add("hidden");
            }
            items.classes.remove("hidden");
          }
        }
      } else {
        /* exit */
        page.remove();
      }
    };
  }
</script>
