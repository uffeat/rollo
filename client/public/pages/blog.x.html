<!--
* About
- Blog route based on non-blocking rendering from static data.
- Frontmatter -> meta + html takes place at runtime. Could
  instead be integrated in custom build process, but the current
  runtime solution is pretty fast!
- The frontmatter -> meta + html split is quite primitive, but it works!
- Primarily styled with Tailwind, but
  - uses in-module sheet for more advanced stuff
  - uses Bootstrap for card-stuff.
- Uses residuals rather than query for aux data, which goes against my own 
  recommendations, but nested (residual-based) routing just feels natural 
  for blogs.

* TODO
- The non-blocking rendering is already handled in an OK way, but to further
  improve (and to generally improve the UX) consider introducing:
  - pagination (cursor-based with a fixed chunk size), or
  - a "load more" approach, or
  - an intersection observer-based approach
  ... probably not super trivial in concert with the non-blocking rendering...
- Consider using progressive images... and/or perhaps placeholders.
-->

<style global>
  /* Cards per row */
  #app[state-path="/blog"] [page] {
    --basis: 100%;
  }
  #app[state-path="/blog"][state-md] [page] {
    --gap: 0.5rem;
    --items: 2;
    --basis: calc(calc(100% / var(--items)) - var(--gap));
  }
  #app[state-path="/blog"][state-xl] [page] {
    --items: 3;
  }

  /* Images in post */
  #app[state-path="/blog"] [post] p:has(> img) {
    display: flex;
    justify-content: center;
  }
</style>

<script type="module">
  const { component } = await use("@/component");
  const { layout } = await use("@/layout/");
  const { ref } = await use("@/state");
  const { marked } = await use("@/marked");
  const { YAML } = await use("@/yaml");
  const { router } = await use("@/router/");
  const { toTop } = await use("@/tools/scroll");

  /** Prepare components and component factories */

  const cards = component.div(
    "w-full flex justify-between flex-wrap gap-y-3 gap-x-(--gap) hidden",
    {}
  );
  cards.attribute.cards = true;

  const page = component.main("container mt-3 mb-3", cards);
  page.attribute.page = true;
  /* Card click -> post view (via router) */
  page.on.click = async (event) => {
    const LINK = "a.nav-link";
    if (event.target.matches(LINK) || event.target.closest(LINK)) {
      const card = event.target.closest(`[card]`);
      const path = card.attribute.card;
      await router(`/blog${path}`);
    }
  };

  const Card = ({ abstract, image, path, title }) => {
    const card = component.div(
      "card h-full basis-(--basis)",
      {},
      component.img("card-img-top", { src: `${use.meta.base}${image}` }),
      component.div(
        "card-body nav flex flex-col",
        {},
        component.a(
          "nav-link cursor-pointer",
          component.h1("card-title", { text: title })
        ),
        component.p("card-text", { text: abstract })
      ),
      component.div("card-footer min-h-8")
    );
    card.attribute.card = path;
    return card;
  };

  const Post = ({ html, path }) => {
    const post = component.div({ innerHTML: html });
    post.attribute.post = path;
    return post;
  };

  /** Create interfaces for route */

  const mount = (() => {
    const state = ref();
    state.effects.add(
      (current) => {
        //console.log("current:", current); ////
        if (current) {
          //console.log("Mounting"); ////
          layout.clear(":not([slot])");
          layout.append(page);
        } else {
          //console.log("Unmounting"); ////
          page.remove();
        }
      },
      { run: false }
    );
    return state;
  })();

  const view = await (async () => {
    const paths = (await use("/content/meta/paths.json")).filter((p) =>
      p.startsWith("/blog/")
    );

    const START = "/content".length - 2;
    const END = ".md".length;
    const toRouterPath = (path) => {
      return "/" + path.slice(START, -END).toLowerCase();
    };

    /* Controller for non-blocking rendering */
    const items = new (class Items {
      #_ = {
        index: 0,
        posts: new Map(),
      };

      constructor() {
        /* Populate posts with pwr's */
        paths.forEach((path) => {
          this.#_.posts.set(toRouterPath(path), Promise.withResolvers());
        });
        this.#create();
      }

      async view(path) {
        if (path) {
          path = `/${path}`;
          if (!this.#_.posts.has(path)) {
            return router.error(path);
          }
          const result = this.#_.posts.get(path);
          this.#_.post =
            result instanceof HTMLElement ? result : await result.promise;
          cards.classes.add("hidden");
          page.append(this.#_.post);
          toTop(this.#_.post);
        } else {
          this.#_.post?.remove();
          cards.classes.remove("hidden");
        }
      }

      #create() {
        const _path = paths.at(this.#_.index);
        if (!_path) {
          return;
        }
        const path = toRouterPath(_path);

        use(`/content${_path}`).then((text) => {
          const [yaml, md] = text.split("---").slice(1);
          const meta = YAML.parse(yaml);
          //
          //
          const html = marked.parse(md);
          //
          //
          const card = Card({ path, ...meta });
          //console.log("card:", card);////
          cards.append(card);

          // TODO Lazy creation of post
          const post = Post({ path, html });
          //console.log("post:", post); ////
          const { promise, resolve } = this.#_.posts.get(path);
          resolve(post);
          this.#_.posts.set(path, post);
          this.#create(this.#_.index++);
        });
      }
    })();

    return async (residuals) => {
      await items.view(residuals.at(0));
    };
  })();

  export default function () {
    /* Return route */
    return async (mode, query, ...residuals) => {
      mount(!mode.exit);
      /* NOTE Never residuals on exit */
      await view(residuals);
    };
  }
</script>
